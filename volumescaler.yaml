apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: volumescalers.zghanem.aws
spec:
  group: zghanem.aws
  names:
    kind: VolumeScaler
    listKind: VolumeScalerList
    plural: volumescalers
    singular: volumescaler
    shortNames:
      - vs
  scope: Namespaced
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          required:
            - spec
          properties:
            spec:
              type: object
              required:
                - pvcName
                - threshold
                - scale
                - maxSize
              properties:
                pvcName:
                  type: string
                  description: Name of the PersistentVolumeClaim to monitor.
                threshold:
                  type: string
                  pattern: "^[0-9]+%$"
                  description: Disk usage threshold (e.g., "80%").
                scale:
                  type: string
                  pattern: "^[0-9]+%$"
                  description: Percentage increase to PVC size when threshold is exceeded.
                maxSize:
                  type: string
                  pattern: "^[0-9]+Gi$"
                  description: Maximum size the PVC can scale to.
            status:
              type: object
              properties:
                scaledAt:
                  type: string
                  format: date-time
                  description: Timestamp of the last scaling action.
                reachedMaxSize:
                  type: boolean
                  description: Indicates whether the PVC has reached its maximum size.
      additionalPrinterColumns:
        - name: PVC Name
          type: string
          jsonPath: .spec.pvcName
        - name: Threshold
          type: string
          jsonPath: .spec.threshold
        - name: Scale
          type: string
          jsonPath: .spec.scale
        - name: Max Size
          type: string
          jsonPath: .spec.maxSize
        - name: Scaled At
          type: string
          jsonPath: .status.scaledAt
        - name: Reached Max Size
          type: boolean
          jsonPath: .status.reachedMaxSize
      subresources:
        status: {}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: pvc-resizer
  namespace: default
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: pvc-resizer-role
rules:
  - apiGroups: [""]  # Core API group
    resources: ["pods", "persistentvolumeclaims"]
    verbs: ["get", "list", "watch", "patch"]
  - apiGroups: ["zghanem.aws"]  # Custom API group
    resources: ["volumescalers", "volumescalers/status"]
    verbs: ["get", "list", "watch", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: pvc-resizer-rolebinding
subjects:
  - kind: ServiceAccount
    name: pvc-resizer
    namespace: default
roleRef:
  kind: ClusterRole
  name: pvc-resizer-role
  apiGroup: rbac.authorization.k8s.io
# ---
# apiVersion: v1
# kind: ConfigMap
# metadata:
#   name: volumescaler-script
#   namespace: default
# data:
#   script.sh: |
#     #!/bin/sh

#     set +e

#     # Function to convert size to Gi
#     convert_to_gi() {
#       size=$1
#       unit=$(echo "$size" | grep -oE '[A-Za-z]+')
#       number=$(echo "$size" | grep -oE '[0-9.]+' )

#       case "$unit" in
#         Gi)
#           echo "$number"
#           ;;
#         Mi)
#           echo "scale=2; $number / 1024" | bc
#           ;;
#         Ti)
#           echo "scale=2; $number * 1024" | bc
#           ;;
#         *)
#           echo "$number"  # Default to Gi if unit is unrecognized
#           ;;
#       esac
#     }

#     # Install jq if not present
#     if ! command -v jq >/dev/null 2>&1; then
#       apk add --no-cache jq > /dev/null 2>&1
#     fi

#     while true; do
#       NODE_NAME="$NODE_NAME_ENV"

#       pods_json=$(kubectl get pods --all-namespaces --field-selector spec.nodeName="$NODE_NAME" -o json)
#       if [ $? -ne 0 ]; then
#         echo "Error fetching pods for node $NODE_NAME. Retrying..."
#         sleep 60
#         continue
#       fi

#       echo "$pods_json" | jq -c '.items[]' | while read -r pod; do
#         namespace=$(echo "$pod" | jq -r '.metadata.namespace')
#         pod_uid=$(echo "$pod" | jq -r '.metadata.uid')

#         pvc_list=$(echo "$pod" | jq -r '.spec.volumes[]? | select(.persistentVolumeClaim) | .persistentVolumeClaim.claimName')
#         echo "$pvc_list" | while read -r pvc; do
#           if [ -n "$pvc" ]; then
#             pvc_details=$(kubectl get pvc "$pvc" -n "$namespace" -o json)
#             if [ $? -ne 0 ]; then
#               echo "Error fetching PVC details for $pvc in namespace $namespace."
#               continue
#             fi

#             current_pvc_size_raw=$(echo "$pvc_details" | jq -r '.spec.resources.requests.storage')
#             current_pvc_size=$(convert_to_gi "$current_pvc_size_raw")
#             pvc_uid=$(echo "$pvc_details" | jq -r '.metadata.uid')

#             scaler=$(kubectl get volumescaler "$pvc" -n "$namespace" -o json 2>/dev/null)
#             if [ $? -ne 0 ]; then
#               echo "No VolumeScaler found for PVC: $pvc in namespace $namespace."
#               continue
#             fi

#             threshold=$(echo "$scaler" | jq -r '.spec.threshold' | tr -d '%')
#             scale=$(echo "$scaler" | jq -r '.spec.scale' | tr -d '%')
#             max_size_raw=$(echo "$scaler" | jq -r '.spec.maxSize')
#             max_size=$(convert_to_gi "$max_size_raw")
#             reached_max=$(echo "$scaler" | jq -r '.status.reachedMaxSize // false')

#             # Check if current PVC size >= maxSize
#             is_at_or_beyond_max=$(echo "$current_pvc_size >= $max_size" | bc -l)
#             if [ "$is_at_or_beyond_max" -eq 1 ]; then
#               if [ "$reached_max" != "true" ]; then
#                 echo "PVC '$pvc' in namespace '$namespace' has reached its maxSize of ${max_size}Gi."
#                 kubectl patch volumescaler "$pvc" -n "$namespace" --type=merge -p '{"status": {"reachedMaxSize": true}}'
#               fi
#               continue
#             fi

#             mount_path="/var/lib/kubelet/pods/$pod_uid/volumes/kubernetes.io~csi/pvc-$pvc_uid/mount"
#             if [ -d "$mount_path" ]; then
#               df_output=$(df "$mount_path" 2>/dev/null | tail -1)
#               if [ -n "$df_output" ]; then
#                 used=$(echo "$df_output" | awk '{print $3}')
#                 used_gi=$(echo "$used / 1024 / 1024" | bc -l | awk '{printf "%.2f", $1}')
#                 utilization=$(echo "scale=2; ($used_gi / $current_pvc_size) * 100" | bc | awk '{printf "%.0f", $1}')

#                 # Log utilization before checking threshold
#                 if [ "$utilization" -ge "$threshold" ]; then
#                   last_scaled=$(echo "$scaler" | jq -r '.status.scaledAt' 2>/dev/null)
#                   current_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
#                   if [ -n "$last_scaled" ] && [ $(date -u -d "$last_scaled +6 hours" +"%s") -gt $(date -u +"%s") ]; then
#                     echo "PVC: $pvc was recently scaled. Skipping."
#                     continue
#                   fi

#                   increment_size=$(echo "$current_pvc_size * $scale / 100" | bc)
#                   new_size=$(echo "$current_pvc_size + $increment_size" | bc | awk '{printf "%.0f", $1}')

#                   # Enforce maxSize if needed
#                   greater_than_max=$(echo "$new_size > $max_size" | bc -l)
#                   if [ "$greater_than_max" -eq 1 ]; then
#                     new_size="$max_size"
#                     echo "New size would exceed maxSize. Setting new size to ${max_size}Gi."
#                   fi

#                   # If new_size is the same as current, no need to patch
#                   same_size=$(echo "$new_size == $current_pvc_size" | bc -l)
#                   if [ "$same_size" -eq 1 ]; then
#                     echo "PVC '$pvc' is already at size ${current_pvc_size}Gi. No patch needed."
#                   else
#                     patch_output=$(kubectl patch pvc "$pvc" -n "$namespace" --type='merge' -p "{\"spec\":{\"resources\":{\"requests\":{\"storage\":\"${new_size}Gi\"}}}}" 2>&1)
#                     if [ $? -eq 0 ]; then
#                       echo "Scaled PVC: $pvc, Namespace: $namespace, New Size: ${new_size}Gi"
#                       kubectl patch volumescaler "$pvc" -n "$namespace" --type=merge -p "{\"status\":{\"scaledAt\":\"$current_time\"}}"

#                       # Check how close we are to maxSize
#                       difference=$(echo "$max_size - $new_size" | bc -l)
#                       comp_result=$(echo "$difference <= 1" | bc -l)
#                       if [ "$comp_result" -eq 1 ] && [ "$reached_max" != "true" ]; then
#                         echo "PVC '$pvc' is at or near maxSize (${max_size}Gi). Marking as reached max."
#                         kubectl patch volumescaler "$pvc" -n "$namespace" --type=merge -p "{\"status\":{\"reachedMaxSize\":true}}"
#                       fi
#                     else
#                       echo "Failed to scale PVC: $pvc, Namespace: $namespace. Error: $patch_output"
#                     fi
#                   fi
#                 else
#                   # Keep original descriptive logs
#                   echo "PVC: $pvc, Namespace: $namespace, PVC Size: ${current_pvc_size}Gi, Utilization: ${used_gi}Gi (${utilization}%) and below Threshold (${threshold}%). No scaling needed."
#                 fi
#               else
#                 echo "Error: Unable to get disk usage for PVC: $pvc."
#               fi
#             else
#               echo "Error: Mount path does not exist for PVC: $pvc."
#             fi
#           fi
#         done
#       done

#       sleep 60
#     done
# ---
# apiVersion: apps/v1
# kind: DaemonSet
# metadata:
#   name: volumescaler-daemonset
#   namespace: default
# spec:
#   selector:
#     matchLabels:
#       app: volumescaler
#   template:
#     metadata:
#       labels:
#         app: volumescaler
#     spec:
#       serviceAccountName: pvc-resizer
#       containers:
#         - name: pvc-resizer
#           # image: docker push 374031103815.dkr.ecr.us-east-1.amazonaws.com/kubectl:latest
#           image: 374031103815.dkr.ecr.us-east-1.amazonaws.com/volumescaler:latest
#           imagePullPolicy: Always
#           command: ["/bin/sh", "/scripts/script.sh"]
#           env:
#             - name: NODE_NAME_ENV
#               valueFrom:
#                 fieldRef:
#                   fieldPath: spec.nodeName
#           securityContext:
#             privileged: true
#             readOnlyRootFilesystem: false
#             allowPrivilegeEscalation: true
#           volumeMounts:
#             - name: script-volume
#               mountPath: /scripts
#               readOnly: true
#             - name: kubelet
#               mountPath: /var/lib/kubelet
#               mountPropagation: Bidirectional
#       volumes:
#         - name: script-volume
#           configMap:
#             name: volumescaler-script
#         - name: kubelet
#           hostPath:
#             path: /var/lib/kubelet
#             type: Directory
#       dnsPolicy: ClusterFirst
#       nodeSelector:
#         kubernetes.io/os: linux
#       tolerations:
#         - operator: Exists
#       restartPolicy: Always
#       terminationGracePeriodSeconds: 30
#       priorityClassName: system-node-critical
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: volumescaler-daemonset
  namespace: default
spec:
  selector:
    matchLabels:
      app: volumescaler
  template:
    metadata:
      labels:
        app: volumescaler
    spec:
      serviceAccountName: pvc-resizer
      containers:
        - name: pvc-resizer
          image: 374031103815.dkr.ecr.us-east-1.amazonaws.com/volumescaler:latest
          imagePullPolicy: Always
          # The Go binary should be compiled to run as PID 1 by default
          # If needed, specify command/args if your binary requires them
          env:
            - name: NODE_NAME_ENV
              valueFrom:
                fieldRef:
                  fieldPath: spec.nodeName
          securityContext:
            privileged: true
            readOnlyRootFilesystem: false
            allowPrivilegeEscalation: true
          volumeMounts:
            - name: kubelet
              mountPath: /var/lib/kubelet
              mountPropagation: Bidirectional
      volumes:
        - name: kubelet
          hostPath:
            path: /var/lib/kubelet
            type: Directory
      dnsPolicy: ClusterFirst
      nodeSelector:
        kubernetes.io/os: linux
      tolerations:
        - operator: Exists
      restartPolicy: Always
      terminationGracePeriodSeconds: 30
      priorityClassName: system-node-critical